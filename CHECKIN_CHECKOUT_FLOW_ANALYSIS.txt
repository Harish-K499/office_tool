COMPREHENSIVE CHECKIN/CHECKOUT AND ATTENDANCE PUNCHING FLOW ANALYSIS
========================================================================

Generated: January 6, 2026
System: VTAB Square Office Tool
Version: Complete Flow Documentation

TABLE OF CONTENTS
==================
1. System Architecture Overview
2. Database Schema & Tables
3. API Endpoints & Routes
4. Frontend Components & Flow
5. Real-time Synchronization
6. Business Logic & Rules
7. Status Determination Logic
8. Absent Marking Logic
9. Error Handling & Edge Cases
10. Data Flow Sequence
11. Security & Validation
12. Performance Considerations

1. SYSTEM ARCHITECTURE OVERVIEW
================================

The attendance system follows a multi-tier architecture:

FRONTEND LAYER (JavaScript/React)
├── Timer Component (features/timer.js)
├── Attendance API Layer (features/attendanceApi.js)
├── Attendance UI Pages (pages/attendance.js)
├── Socket Client (features/attendanceSocket.js)
└── State Management (state.js)

BACKEND LAYER (Python Flask)
├── Unified Server (backend/unified_server.py)
├── Attendance Backend Logic (backend/attendance_backend.py)
├── Dataverse Helper (backend/dataverse_helper.py)
└── Socket Server Integration

DATABASE LAYER (Microsoft Dataverse)
├── Attendance Table (crc6f_table13s)
├── Employee Master (crc6f_table12s)
├── Holiday Calendar (crc6f_hr_holidayses)
└── Login Activity Tracking

REAL-TIME LAYER (Socket.io)
├── Attendance Module (socket-server/attendance_module.js)
├── Multi-device Synchronization
└── Auto-status Broadcasting

2. DATABASE SCHEMA & TABLES
===========================

PRIMARY ATTENDANCE TABLE: crc6f_table13s
--------------------------------------
Primary Key: crc6f_table13id (GUID)
Business Key: crc6f_attendanceid (Format: ATD-XXXXXXX)

Core Columns:
- crc6f_employeeid: Employee identifier (FK to employee master)
- crc6f_date: Date of attendance record (YYYY-MM-DD)
- crc6f_checkin: Check-in time (HH:MM:SS format)
- crc6f_checkout: Check-out time (HH:MM:SS format)
- crc6f_duration: Duration in hours (numeric)
- crc6f_duration_intext: Human readable duration ("N hour(s) M minute(s)")
- crc6f_checkinlocation: GPS coordinates of check-in
- crc6f_checkoutlocation: GPS coordinates of check-out
- crc6f_checkin_timestamp: Epoch timestamp for check-in
- crc6f_checkout_timestamp: Epoch timestamp for check-out
- crc6f_total_seconds: Total seconds worked for the day

EMPLOYEE MASTER TABLE: crc6f_table12s
------------------------------------
Primary Key: crc6f_table12id
Business Key: crc6f_employeeid
Key Columns: crc6f_firstname, crc6f_lastname, crc6f_email, crc6f_designation
Status: crc6f_activeflag (determines if employee can punch)

HOLIDAY CALENDAR TABLE: crc6f_hr_holidayses
-------------------------------------------
Primary Key: crc6f_hr_holidaysid
Key Columns: crc6f_date, crc6f_holidayname
Purpose: Marks official holidays for attendance calculations

3. API ENDPOINTS & ROUTES
=========================

CHECKIN ENDPOINT: POST /api/checkin
----------------------------------
Request Payload:
{
  "employee_id": "EMP001",
  "client_time": "2026-01-06T09:15:00.000Z",
  "timezone": "Asia/Kolkata",
  "location": {
    "lat": 12.9716,
    "lng": 77.5946,
    "accuracy_m": 10,
    "source": "browser"
  }
}

Response:
{
  "success": true,
  "record_id": "GUID-string",
  "checkin_time": "09:15:00",
  "total_seconds_today": 0,
  "checkin_timestamp": 1704531300000
}

CHECKOUT ENDPOINT: POST /api/checkout
------------------------------------
Request Payload:
{
  "employee_id": "EMP001",
  "client_time": "2026-01-06T18:30:00.000Z",
  "timezone": "Asia/Kolkata",
  "location": {
    "lat": 12.9716,
    "lng": 77.5946,
    "accuracy_m": 10,
    "source": "browser"
  }
}

Response:
{
  "success": true,
  "checkout_time": "18:30:00",
  "duration": "9 hour(s) 15 minute(s)",
  "total_hours": 9.25,
  "total_seconds_today": 33300
}

STATUS ENDPOINT: GET /api/status/{employee_id}
--------------------------------------------
Response:
{
  "checked_in": true,
  "elapsed_seconds": 1800,
  "total_seconds_today": 14400,
  "checkin_time": "09:15:00",
  "checkin_datetime": "2026-01-06T09:15:00.000Z"
}

MONTHLY ATTENDANCE: GET /api/attendance/{employee_id}/{year}/{month}
------------------------------------------------------------------
Response:
{
  "success": true,
  "records": [
    {
      "day": 1,
      "date": "2026-01-01",
      "status": "P",
      "checkIn": "09:15:00",
      "checkOut": "18:30:00",
      "duration": "9 hour(s) 15 minute(s)",
      "totalHours": 9.25,
      "isLate": false,
      "isManual": false,
      "leaveType": null
    }
  ]
}

AUTO-STATUS UPDATE: POST /api/attendance/auto-status
---------------------------------------------------
Request Payload:
{
  "employee_id": "EMP001",
  "total_seconds": 14400,
  "status": "P"
}

MANUAL EDIT: POST /api/attendance/manual-edit
---------------------------------------------
Request Payload:
{
  "employee_id": "EMP001",
  "year": 2026,
  "month": 1,
  "day": 15,
  "code": "P"  // P, HL, A
}

4. FRONTEND COMPONENTS & FLOW
=============================

TIMER COMPONENT (features/timer.js)
----------------------------------
Core Functions:
- handleTimerClick(): Main entry point for checkin/checkout
- startTimer(): Handles check-in flow with optimistic UI updates
- stopTimer(): Handles check-out flow with duration calculation
- updateTimerDisplay(): Updates timer display every second
- loadTimerState(): Restores timer state from backend/localStorage
- updateTimerButton(): Updates button state (CHECK IN/CHECK OUT)

Key Features:
- Optimistic UI updates for instant feedback
- Geolocation capture (high accuracy → low accuracy fallback)
- Multi-device synchronization via sockets
- Automatic midnight reset
- Local storage persistence
- Backend state reconciliation

ATTENDANCE API LAYER (features/attendanceApi.js)
-----------------------------------------------
Functions:
- checkIn(employeeId, location): Calls backend checkin endpoint
- checkOut(employeeId, location): Calls backend checkout endpoint
- fetchMonthlyAttendance(employeeId, year, month): Gets monthly data
- fetchAllAttendance(employeeId): Gets all historical data
- fetchTeamMonthlyAttendance(employeeIds, year, month): Team view data
- submitAttendanceToInbox(employeeId, year, month): Submit for approval

Features:
- 2-minute response caching
- Error handling with user-friendly messages
- Timeout protection via timedFetch
- Automatic cache invalidation on updates

ATTENDANCE UI PAGES (pages/attendance.js)
----------------------------------------
Main Functions:
- renderAttendanceTrackerPage(mode): Renders My/Team attendance
- getStatusCellHTML(): Generates status cell with all indicators
- openTeamAttendanceEditModal(): Admin manual edit interface
- exportTeamAttendanceToCSV(): Export functionality
- loadHolidaysForMonth(): Holiday integration

Status Indicators:
- P: Present (green)
- A: Absent (red)
- HL: Half Day (orange)
- CL: Casual Leave (blue)
- SL: Sick Leave (purple)
- CO: Comp Off (teal)
- INL: Indian National Holiday (brown)

Special Indicators:
- Late entry icon (fa-clock-rotate-left)
- Manual entry icon (fa-hand)
- Pending status icon (fa-triangle-exclamation)
- LOP text for unpaid leaves

5. REAL-TIME SYNCHRONIZATION
============================

SOCKET SERVER (socket-server/attendance_module.js)
-------------------------------------------------
Events Handled:
- attendance:register: User joins their attendance room
- attendance:checkin: Broadcast check-in to all user devices
- attendance:checkout: Broadcast check-out to all user devices
- attendance:request-sync: Client requests current state
- attendance:sync: Push current timer state
- attendance:status-update: Auto status change broadcast

Multi-Device Sync Logic:
1. User registers with employee_id on connection
2. Socket server maintains activeTimers in memory
3. Check-in/check-out events broadcast to all user devices
4. Status changes (4h=HL, 9h=P) auto-broadcast every minute
5. New devices get current state via sync on registration

Conflict Resolution:
- User action timestamps prevent socket override for 5 seconds
- Backend state is authoritative on page load
- Optimistic updates roll back on API failure
- Socket sync ignored during user interactions

6. BUSINESS LOGIC & RULES
=========================

CHECK-IN RULES:
--------------
1. Employees can only check-in if activeflag = true
2. Multiple check-ins per day allowed (continues existing session)
3. Check-in time recorded in both HH:MM:SS and epoch timestamp
4. Geolocation captured (optional, fallback to null)
5. Random attendance ID generated: ATD-XXXXXXX
6. Session stored in backend memory for duration calculation

CHECK-OUT RULES:
---------------
1. Must have active check-in session
2. Duration calculated from check-in time
3. Duration aggregated for multiple sessions in same day
4. Both numeric (hours) and text duration stored
5. GPS location captured on checkout
6. Session cleared from memory after checkout

DURATION CALCULATION:
-------------------
Formula: checkout_time - checkin_time = session_duration
Total daily duration = sum of all session durations
Status derived from total seconds:
- < 4 hours (14400 sec): Absent (A)
- 4-9 hours (14400-32400 sec): Half Day (HL)
- ≥ 9 hours (32400+ sec): Present (P)

7. STATUS DETERMINATION LOGIC
=============================

AUTOMATIC STATUS UPDATES:
------------------------
Real-time status calculation runs every minute:

```javascript
function deriveStatus(totalSeconds) {
  if (totalSeconds >= FULL_DAY_SECONDS) return 'P';  // 9 hours
  if (totalSeconds >= HALF_DAY_SECONDS) return 'HL'; // 4 hours
  return 'A'; // Absent
}
```

STATUS FLOW:
-----------
1. Check-in: Status starts as 'A' (0 seconds)
2. 4 hours crossed: Auto-updates to 'HL'
3. 9 hours crossed: Auto-updates to 'P'
4. Check-out: Final status locked based on total duration
5. Manual override: Admin can set P/HL/A via manual edit

STATUS PERSISTENCE:
-----------------
- Status stored in Dataverse attendance record
- Real-time updates broadcast via sockets
- Frontend reflects changes immediately
- History maintained for reporting

8. ABSENT MARKING LOGIC
======================

WHEN IS AN EMPLOYEE MARKED ABSENT?
---------------------------------

1. NO CHECK-IN BY END OF DAY:
   - System runs midnight job/check
   - If no check-in record exists for date
   - Status = 'A' (Absent)
   - No duration recorded

2. LESS THAN 4 HOURS TOTAL:
   - Employee checks in and out
   - Total duration < 4 hours (14400 seconds)
   - Status automatically = 'A'
   - Duration still recorded for audit

3. MANUAL MARKING BY ADMIN:
   - Admin uses manual edit interface
   - Sets status to 'A' explicitly
   - Overwrites any automatic calculation
   - Reason can be added in comments

ABSENCE DETECTION ALGORITHM:
---------------------------
```python
def check_absence(employee_id, date):
    # Get attendance record for date
    record = get_attendance_record(employee_id, date)
    
    if not record:
        # No record = absent
        return 'A'
    
    if not record.checkin_time:
        # No check-in = absent
        return 'A'
    
    if not record.checkout_time:
        # Check-in but no checkout (still running or forgot)
        # Check if current time > end of workday
        if current_time > workday_end:
            return 'A'  # Forgot to checkout
        else:
            return None  # Still working
    
    # Calculate total duration
    total_seconds = calculate_total_duration(record)
    
    if total_seconds < HALF_DAY_SECONDS:
        return 'A'
    elif total_seconds < FULL_DAY_SECONDS:
        return 'HL'
    else:
        return 'P'
```

WEEKEND/HOLIDAY HANDLING:
------------------------
- Weekends: No automatic absent marking
- Holidays: Marked as 'INL' (Indian National Holiday)
- Leave requests: Override absent status with leave codes
- Half days: Can be 'HL' if partial attendance

9. ERROR HANDLING & EDGE CASES
==============================

COMMON ERROR SCENARIOS:
-----------------------

1. DUPLICATE CHECK-IN:
   - System allows multiple check-ins per day
   - Continues existing session instead of creating new record
   - Aggregates duration across sessions

2. CHECKOUT WITHOUT CHECKIN:
   - API returns error: "No active check-in found"
   - Frontend shows error message
   - Timer state remains unchanged

3. NETWORK FAILURES:
   - Optimistic UI updates provide immediate feedback
   - API failures trigger rollback of UI state
   - Local storage maintains state for retry

4. TIMEZONE ISSUES:
   - Client timezone captured and sent to backend
   - All times stored in UTC on server
   - Display converted to user's local timezone

5. GEOLOCATION DENIED:
   - Graceful fallback to null location
   - Check-in/check-out still allowed
   - Warning shown to user

6. MULTIPLE DEVICE CONFLICTS:
   - Socket synchronization resolves conflicts
   - Last user action takes precedence
   - Backend state is authoritative

VALIDATION RULES:
----------------
- Employee ID must exist and be active
- Date must be current or past (future check-ins blocked)
- Check-out time must be after check-in time
- Duration cannot exceed 24 hours
- Location coordinates must be valid ranges

RECOVERY MECHANISMS:
-------------------
- Backend session recovery on page load
- Local storage fallback for offline mode
- Automatic sync on reconnection
- Midnight reset prevents stale state

10. DATA FLOW SEQUENCE
======================

COMPLETE CHECK-IN FLOW:
----------------------
1. USER CLICKS "CHECK IN"
   ↓
2. FRONTEND: handleTimerClick() → startTimer()
   - Optimistic UI update (timer starts immediately)
   - Record user action to prevent socket override
   - Save state to localStorage
   ↓
3. GEOLOCATION CAPTURE
   - High accuracy GPS (15s timeout)
   - Fallback to low accuracy if denied
   - Continue without location if both fail
   ↓
4. API CALL: POST /api/checkin
   - Send employee_id, client_time, timezone, location
   ↓
5. BACKEND: checkin() function
   - Validate employee and permissions
   - Generate random attendance ID (ATD-XXXXXXX)
   - Create Dataverse record with check-in time
   - Store session in memory
   - Emit socket event for multi-device sync
   ↓
6. RESPONSE TO FRONTEND
   - Update timer with backend timestamp
   - Sync duration if backend has different total
   - Update attendance state for today
   ↓
7. UI REFRESH
   - Timer display shows elapsed time
   - Attendance page updates if visible
   - Status shows as working

COMPLETE CHECK-OUT FLOW:
-----------------------
1. USER CLICKS "CHECK OUT"
   ↓
2. FRONTEND: handleTimerClick() → stopTimer()
   - Optimistic UI update (timer stops)
   - Calculate local duration
   - Save state to localStorage
   ↓
3. GEOLOCATION CAPTURE
   - Same fallback logic as check-in
   ↓
4. API CALL: POST /api/checkout
   - Send employee_id, client_time, timezone, location
   ↓
5. BACKEND: checkout() function
   - Validate active session exists
   - Calculate session duration
   - Add to existing daily duration
   - Update Dataverse record with checkout and duration
   - Clear session from memory
   - Emit socket event for multi-device sync
   ↓
6. RESPONSE TO FRONTEND
   - Update final duration from backend
   - Determine final status (P/HL/A)
   - Update attendance state
   ↓
7. UI REFRESH
   - Timer shows final duration
   - Status indicator updates
   - Attendance page reflects final state

ABSENCE DETECTION FLOW:
----------------------
1. MIDNIGHT RESET TRIGGERS
   ↓
2. SYSTEM CHECKS FOR YESTERDAY'S RECORDS
   ↓
3. FOR EACH ACTIVE EMPLOYEE:
   - If no attendance record exists → Mark 'A'
   - If record exists but no check-in → Mark 'A'
   - If total duration < 4 hours → Mark 'A'
   - If duration 4-9 hours → Mark 'HL'
   - If duration ≥ 9 hours → Mark 'P'
   ↓
4. UPDATE DATAVERSE RECORDS
   ↓
5. NOTIFY MANAGERS OF ABSENTEES (optional)

11. SECURITY & VALIDATION
=========================

AUTHENTICATION & AUTHORIZATION:
------------------------------
1. JWT TOKEN VALIDATION
   - All API endpoints require valid Bearer token
   - Token verified against Dataverse user table
   - Employee ID extracted from token context

2. EMPLOYEE STATUS CHECKS
   - Activeflag must be true in employee master
   - Inactive employees cannot punch attendance
   - Termination date checked if present

3. ROLE-BASED ACCESS
   - Regular users: Own attendance only
   - Managers: Team attendance view
   - Admins: Full access + manual editing
   - Designation field determines access level

INPUT VALIDATION:
----------------
1. EMPLOYEE ID
   - Must exist in employee master
   - Must be alphanumeric with specific format
   - Case insensitive (stored as uppercase)

2. TIME VALUES
   - Must be valid time format (HH:MM:SS or ISO)
   - Check-out must be after check-in
   - Cannot be in future (except for admin edits)

3. LOCATION DATA
   - Latitude: -90 to 90 degrees
   - Longitude: -180 to 180 degrees
   - Accuracy: positive number in meters

4. DURATION LIMITS
   - Maximum 24 hours per day
   - Minimum 1 minute for valid session
   - Total seconds must be reasonable

AUDIT & LOGGING:
---------------
1. API CALL LOGGING
   - All check-in/out endpoints logged
   - Employee ID, timestamp, location recorded
   - Error conditions tracked

2. DATAVERSE AUDIT
   - Dataverse maintains change tracking
   - Record creation/modification timestamps
   - User attribution for all changes

3. SOCKET EVENT LOGGING
   - All socket events logged
   - Multi-device sync tracked
   - Conflict resolution logged

12. PERFORMANCE CONSIDATIONS
============================

OPTIMIZATIONS IMPLEMENTED:
--------------------------

1. OPTIMISTIC UI UPDATES
   - Timer starts/stops instantly on click
   - No waiting for API response
   - Rollback on failure

2. RESPONSE CACHING
   - Monthly attendance cached for 2 minutes
   - Reduces Dataverse API calls
   - Cache invalidated on updates

3. BATCH OPERATIONS
   - Team attendance fetched in single API call
   - Holiday data cached per month
   - Employee data cached per session

4. LAZY LOADING
   - Attendance data loaded on demand
   - Pagination for large datasets
   - Background data refresh

5. EFFICIENT STATE MANAGEMENT
   - In-memory timer state
   - LocalStorage persistence
   - Minimal re-renders

SCALABILITY CONSIDATIONS:
------------------------

1. DATABASE INDEXING
   - Employee ID + Date composite index
   - Attendance ID unique index
   - Timestamp indexes for reporting

2. SOCKET SERVER SCALING
   - Memory-based timer storage
   - Automatic cleanup on disconnect
   - Room-based broadcasting

3. API RATE LIMITING
   - Check-in/out limited per user
   - Prevents API abuse
   - Graceful degradation

MONITORING & ALERTS:
-------------------
1. PERFORMANCE METRICS
   - API response times tracked
   - Socket latency monitored
   - Database query performance

2. ERROR MONITORING
   - Failed check-ins logged
   - Socket connection issues tracked
   - Database errors monitored

3. BUSINESS METRICS
   - Daily check-in compliance
   - Late arrival statistics
   - Absence patterns

CONCLUSION
==========

This comprehensive attendance system provides:

✅ Real-time multi-device synchronization
✅ Automatic status determination based on duration
✅ Robust absent marking logic
✅ Geolocation tracking with fallbacks
✅ Admin override capabilities
✅ Comprehensive audit trail
✅ Performance optimizations
✅ Error handling and recovery
✅ Security validations
✅ Holiday and leave integration

The system handles all edge cases including network failures, timezone issues, multiple device conflicts, and provides a seamless user experience with optimistic updates and real-time synchronization.

Absent marking occurs automatically when:
- No check-in record exists for a day
- Total worked time is less than 4 hours
- Admin manually marks as absent
- System detects forgotten checkout after workday end

The architecture ensures data consistency across all components while maintaining high performance and reliability for enterprise attendance tracking.
